h1. Google Java Style (和訳)


--------------
h2. この文書について

本文書はGoogleのJavaコーディング規約である "Google Java Style":http://google-styleguide.googlecode.com/svn/trunk/javaguide.html の非公式和訳です。技術的に正確である事を意図して訳してありますが、どこかで間違えているかもしれません。さらに言えば翻訳作業途中です。生暖かく見守ってやってください。誤訳、誤植の指摘を歓迎いたします。

--------------


h2. 1 導入

この文書はJavaプログラミング言語のソースコードのGoogleのコーディング標準の *完全* な定義を提供する。
下記のルールに従うJavaソースファイルのみが、Googleスタイルであるとみなされる。

他のプログラミングスタイルガイドのように、問題の対象範囲は審美的なフォーマットの問題だけでなく他の種類の規約やコーディング標準も含まれる。しかしながらこの文書は私達が全世界的に従う *当然の規則* に優先的に注力しており（人間でもマシンでも）明確に実施できない助言をすることを避けている。


h3. 1.1 用語についての注記


本文書において、特別に断りのない限り、

# クラスという用語は、「通常の」クラス、列挙型  、インターフェース、アノテーション型(@interface)を包括的に意味する。
# コメントという用語は、常に実装のコメントを意味する。「ドキュメンテーションコメント」という言い方は使わない。代わりに共通的に使われている、「Javadoc」という言葉を使う。


他ものへの用語の注記は必要に応じて本文書を通じて現れる。



h3. 1.2 ガイドについての注記

Example code in this document is non-normative. 
That is, while the examples are in Google Style, they may not illustrate the only 
stylish way to represent the code. 
Optional formatting choices made in examples should not be enforced as rules.

この文書内のサンプルコードは規約に *従っていない。* つまり、サンプルコードはGoogleスタイル文書に書かれているが、コードを表現する唯一のスタイルに則ったやり方を説明していないかもしれない。例に出される補足的な整形の仕方はルールとして強調されるべきではない。

h2. 2 ソースファイルの基本

h3.  2.1 ファイル名



The source file name consists of the case-sensitive name of the top-level class it contains, 
plus the .java extension.

ソースファイル名はそれが入っているトップレベルクラスの大文字小文字を区別した名前と加えて @.java@ という拡張子が付いていること。


h3. 2.2 ファイルエンコーディング：UTF-8

ソースファイルはUTF-8でエンコードされていること。


h3. 2.3 特殊文字

h4. 2.3.1 空白

行区切り文字以外では、 ASCII水平スペース文字 (0x20)  はソース内でどこに現れても良い唯一の空白文字です。
つまり、

# Stringと文字リテラルでのこれ以外の空白文字はエスケープされること。
# タブ文字をインデントの目的で *使ってはいけない。*

ことを意味します。


h4. 2.3.2 特殊文字シーケンス

特殊なエスケープシーケンスを持つ全ての文字(\b, \t, \n, \f, \r, \", \' と \\\\)については
8進数表記(\\012)やUnicodeエスケープ(\\u000a)でなく、通常のエスケープシーケンスで表記する。


h4. 2.3.3 非ASCII文字

残りの非ASCII文字については *ソースコードを読むことや理解することが簡単になる* かどうかのみを基準にして
実際のUnicode文字（例：∞）あるいは同等のUnicodeエスケープ(例： \\u221e)を使うかの判断を行う。


TIP: Unicodeエスケープの場合、時たま実際にUnicode文字が使われている時でも説明のコメントがあるとわかりやすいです。



|例                           |説明|
|String unitAbbrev = "μs";                             |最高。コメントなしでも完全で明確|
|String unitAbbrev = "\u03bcs"; // "μs"                |許容される。しかしこう書く理由はない|
|String unitAbbrev = "\u03bcs"; // ギリシャ文字ミューと "s" |許容される。しかし奇妙で間違えやすい|
|String unitAbbrev = "\u03bcs";                         |だめ。読者やこれが何なのか分からない|
|return '\ufeff' + content; // バイトオーダーマーク     |良い。表示されない文字にはエスケープを使い必要ならコメントする|



> TIP: 単に何かのプログラムが非ASCII文字を正しく処理しないからといってコードを読みにくくしないで下さい。もしそのような事が起こる場合はそのプログラムがおかしいのであってプログラムが修正されるべきです。


h2. 3 ソースファイル構造


ソースファイルの内容は以下の順序であること。

1. ライセンスあるいはコピーライトの情報（もしあるならば）
2. package文
3. import文
4. ただ1個のトップレベルクラス。

それぞれの分離には *ただ1個の空行* を使うこと。


h3. 3.1 ライセンスあるいはコピーライトの情報（もしあるならば）


もしファイルにライセンスあるいはコピーライトの情報があるならばここに入る。

h4. 3.2 パッケージ文

パッケージ文は *行折り返ししてはならない。* 文字数制限（4.4節文字数制限は80あるいは100文字）はパッケージ文には適用されない。

h3. 3.3 インポート文

h4. 3.3.1 ワイルドカードインポートは禁止

*ワイルドカードインポート* はstaticであってもなくても *使ってはならない。*

h4. 3.3.2 改行禁止

import文は *改行してはならない。* 文字数制限（4.4節文字数制限は80あるいは100文字）はimport文には適用されない。

h4. 3.3.3 順序と空白


インポート文は以下のグループに以下の順序で分けられる。グループは1行の空白で分離される。

# すべてのstatic importを単一のグループにまとめる。
# com.google のインポート。（ソースファイルがcom.googleパッケージに属する場合のみ）
# サードパーティのインポート。トップレベルパッケージ毎に1個のグループとしASCII文字の順序で
** 例：android, com, junit, org, sun
# java パッケージのインポート
# javax パッケージのインポート


空行が無いグループ毎にインポートした名前はASCII順に並べなければならない。（ *注釈：* これはセミコロンの存在がソート結果を変えてしまうという意味でインポート文がASCII順になっていることと同じではない。）

h3. 3.4 クラス宣言

h4. 3.4.1 正確に1個のトップレベルクラスの宣言

各トップレベルクラスは1個のファイルに保存される。

h4. 3.4.2 クラスメンバーの順序

クラスメンバーの順序はわかりやすさに多大な影響を与えるが唯一の解法は無い。クラス毎にメンバーの並びが異なっていて良い。

重要な事はそれぞれのクラスのメンバーは誰かに訊かれた時に答えられるような *何らかの合理的な順序* で並べることである。例えば新しいメソッドはクラスの最後になんとなくで追加されてはならない。それは追加された日の順になっているだけであって、論理的ではない。

h5. 3.4.2.1 オーバーロードを分離してはならない

クラスに複数のコンストラクタや同じ名前を持つメソッドがある場合は連続して並べる。間に別のメンバーを入れてはならない。


h2. 4 フォーマット

用語についての注釈："block-like construct"とは、クラス、メソッド、コンストラクタの本体を指す。すべての配列は必要に応じて"block-like construct"とみなされて良い。4.8.3.1節 配列初期化子を参照。

h3. 4.1 中括弧

h4. 4.1.1 使えるところでは中括弧は使う

括弧は @if else for do while@ 文において本体が空でも1行しかなくても使われる。

h4. 4.1.2 空でないブロックではK&Rスタイルに従う。


中括弧は空でないブロックや、ブロックのような構造物ではカーニハン・リッチースタイル( "Egyptian Brackets":http://blog.codinghorror.com/new-programming-jargon/ )に従う。


* 開始中括弧の前に改行を入れない。
* 開始中括弧の後に改行を入れる。
* 終了中括弧の前に改行を入れる。
* もし終了中括弧が文やメソッドの本体を終えるならばその中括弧の後に改行を入れる。例えば終了中括弧の後に @else@ や、カンマが続く場合は改行をしない。

例：

<pre>
return new MyClass() {
  @Override public void method() {
    if (condition()) {
      try {
        something();
      } catch (ProblemException e) {
        recover();
      }
    }
  }
};
</pre>

列挙型でのいくつかの例外はセクション4.8.1 列挙型にて示される。


h4. 4.1.3 空ブロックは簡潔に

空ブロックや空のブロックのような構造物は開始括弧直後に文字や改行無しで閉じてよい。（{}）
但し、 @if/else-if/else@ あるいは @try/catch/finally@ のような複数ブロックの文の場合を除く。

例：

<pre>
void doNothing() {} 
</pre>


h3. 4.2 ブロックのインデントは空白2個である


新しいブロックあるいはブロック構造物が開始した時インデントは空白2個づつ増える。ブロックが終了したら、インデントは1個まえのレベルに戻る。インデントレベルはブロックを通じてコードとコメントに適用される。4.1.2節の例を参照のこと。（ 4.1.2 空でないブロックではK&Rスタイルに従う。）


h3. 4.3 1行毎に1個の文

各文は、末尾に改行が来なくてはならない。

h3. 4.4 1行の文字数制限 80文字か100文字

プロジェクトごとに1行の文字数制限を80文字か100文字いずれかで自由に決定して良い。以下の例外を除き、この制限を超えた行は4.5節 行の折り返しで述べるように改行されなくてはならない。

例外：


1. 文字数制限に従うのが不可能の場合。（例えば、Javadoc内の長いURL、長いJSNIメソッド参照）
2. パッケージ文とインポート文　（3.2 パッケージ文　と3.3 インポート文を参照のこと）
3. コメント内の、コンソールにコピー＆ペーストされるようなコマンド。

h3. 4.5 行の折り返し

用語の注記：別の意味で正当に単一行を占めているコードを複数行に分けるとき、通常は文字数制限を超えないように分ける。この活動を行の折り返しと呼ぶ。


どんな状況にも合う改行方法を正確に示す、統一的で決定的なやり方はありません。同じコード片を改行する正しい方法は複数あるものです。


TIP:　メソッドやローカル変数の抽出は改行をせずに問題を解決する場合があります。


h3. 4.5.1 どこで改行するか

改行の第一原則は、 *高い文法のレベル* で改行することです。つまり、

# 代入でない演算子で改行するときは、シンボルの前で改行します。（これはJavaScriptやC++のような他の言語でのGoogleスタイルで使われている週間と同じであることに注意して下さい）
** このことはドット演算子( . )や、型演算子の＆記号( <T extends Foo & Bar> )や、catch節でのパイプ記号 (catch (FooException | BarException e))といった演算子のようなシンボルにも適用されます。
# 行が代入演算子で改行されるときは、通常シンボルの後ろで改行します。しかしどちらでも受け入れられます。
** このことは拡張for ("foreach") 文の「代入演算子のような」コロンにも適用されます。
# メソッドやコンストラクタ名に続く開始括弧（(）はそれに続いて書かれます。改行されません。
# カンマ(,)はその前のトークンに続いて書かれます。改行されません。

h4. 4.5.2 連続する行は少なくとも４文字インデントします。

改行の際、連続する先頭行後の各行は少なくとも空白4個分元からインデントされます。

複数の連続した行がある場合、インデントは4以上ならいくつでも良いです。一般的に、2個の連続した行が同じインデントレベルであるならばその時のみ、文法的に並行した要素で始まるべきです。

"4.6.3節の水平位置揃え"はあるトークンを前の行に揃えるため色々な数の空白を使うというげんなりするやり方を防止します。

TODO:要推敲

h3. 4.6 空白

h4. 4.6.1 垂直の空白

単一の空行が生成される状況は以下のとおり。

# クラスの連続するメンバ（あるいは初期化子）の間。フィールド、コンストラクタ、メソッド、ネストしたクラス、static初期化子、インスタンス初期化子。
** *例外* ：2個の連続するフィールド（その間にコードがないもの）間での空行は任意である。そのような空行はフィールドの論理的なグループ分けをするのに必要である。
# メソッド本体内で、文を論理的にグループ分けしたい場合。
# 必要な場合、クラスの最初のメンバーの前と最終メンバーの後。（推奨も拒否もしない）
# 本文書の別の節で入れるよう求められた場所（3.3節のインポート文など）

複数の連続した空行を入れて良いが、必須でも推奨でもない。


h4. 4.6.2 水平の空白



言語かあるいは他のスタイルルールの要求であるかによらず、リテラル、コメント、Javadoc以外で単一のASCII空白は以下の場所 *のみ* において使って良い。

# 予約語（if, for , catch）とその行での開始小括弧 (()の間。
# 予約語（else, catch）とその行での前に来る終了中括弧(})との間。
# 開始中括弧({)の前すべて。ただし以下の2個の例外を除く
** @SomeAnnotation({a, b}) (空白は使わない。)
** String[][] x = {{"foo"}};　({{ の中に空白は不要。項目8を参照)
#  すべてのバイナリ、tenary演算子の両側。また、以下の様な演算子ライクなシンボルにも適用する。
** 連続する型パラメータ間のアンパサンド。 @<T extends Foo & Bar>@
** 複数の例外を処理するcatchブロックでのパイプ。 @catch (FooException | BarException e)@
** 拡張for文　("foreach") でのコロン。 (:) 
# , : ; あるいはキャストの閉じ括弧 （)） の後ろ。
# 行末コメントを開始するスラッシュ２個　（//）の両側。ここでは複数の空白が許されるが必須ではない。
# 型と変数の宣言の間。 @List<String> list@
# 任意で、配列初期化子の両括弧の中。
** @new int[] {5, 6} @ と   @ new int[] { 5, 6 }@ は両方有効。

注意：このルールは行頭行末の空白について要求も禁止もしない。内側の空白のみについて当てはまる。


h4. 4.6.3  水平位置揃え 全く不要


用語の注釈：水平位置揃えは前の行のあるトークンの真下にトークンが来るようにコードに追加のスペースを幾つか入れるやり方のことです。

これはやって良いがGoogleスタイルでは *要求されない。* すでに為されているところをそのように維持することすら求めれられない


これはやっている例とやっていない例です。

<pre>
private int x; // これは良い
private Color color; // これも良い

private int   x;      // 許容される。しかし今後の編集で
private Color color;  // 揃えられなくなるかもしれない。
</pre>


カラムの調整は可読性を上げるが将来のメンテナンスで問題になる。一行だけ直したいときを考えてほしい。この変更は以前のきれいな並びをおかしくするだろう。そして *実際そうなる。* このことは開発者(多分君)に近くの行を同様になおせと求める。そして修正範囲の拡大を引き起こす。一行の変更が核爆発になる。最悪意味のない作業になる。良くても変更履歴を汚くする。レビューが遅くなり、マージの衝突が激増する。


h3. 4.7 グループ化の括弧 推奨

追加のグループ化の括弧は作者とレビュアーが括弧なしでもコードは誤解される余地がないと認めるか、コードを読みやすく書いた時のみなくすことが出来ます。すべての読者がJava演算子の優先度表を記憶していると仮定するのは合理的でありません。


h3. 4.8 各構造物

h4. 4.8.1 列挙型

列挙定数値後のカンマの後ろの改行は任意である。

定数値にメソッドもドキュメンテーションもない列挙型は必要に応じて任意に配列の初期化と同じやり方で整形してよい。

<pre>private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }</pre>

列挙型はクラスであるのでクラスに適用される他のルールが適用される。

h4. 4.8.2 変数宣言

h5. 4.8.2.1 One variable per declaration 

宣言ごとに一個の変数

フィールドでもローカル変数でも変数宣言は一個だけの変数を宣言する。 @ int a, b;@ のような宣言は使われない。

h5. 4.8.2.2 必要なときに宣言して速やかに初期化する

ローカル変数はそれを含むブロックやブロック構造物の先頭でなんとなく宣言されてはならない。代わりに、ローカル変数はそのスコープを最小化するために最初に使う場所(理由がある)の近くで宣言される。ローカル変数宣言はたいていは初期化子がある。あるいは宣言直後に初期化される。


h4. 4.8.3 配列

h5. 4.8.3.1 配列の初期化はブロックのようにやって良い。

配列の初期化はあたかも「block-like construct」のようにやって良い。例えば以下の例はすべて有効である。網羅的なリストでは無い。

<pre>
new int[] {           new int[] {
  0, 1, 2, 3            0,
}                       1,
                        2,
new int[] {             3,
  0, 1,               }
  2, 3
}                     new int[]
                          {0, 1, 2, 3}
</pre>


h5. 4.8.3.2 Cのような宣言は禁止

角括弧は型の一部を為すが、変数には当てはまらない。　<pre>String[] args </pre> は良い。 <pre>String args[]</pre> はダメ。


h4. 4.8.4 スイッチ文

 *用語についての注釈* スイッチブロックの括弧の内側は一個以上の文グループです。それぞれの文グループは一個以上のスイッチラベル（case FOO: でも default:　であっても）とそれに続く続く一個以上の文です。


h5. 4.8.4.1 インデンテーション

他のブロックがそうであるように、スイッチブロックのインデントは2です

スイッチラベルの後改行が入り、あたかもブロックが開始したかのようにインデントレベルは2上がります。次のスイッチラベルはあたかもブロックの終わったように前のインデンテーションレベルに戻ります。

h5. 4.8.4.2 フォールスルー コメントを入れる


スイッチブロック内では、各ステートメントグループは突然止まる（ @break@ か @continue@ か @return@ か例外スローか）か実行が次のステートメントグループに進むようなコメントが付けられるかのみです。フォールスルーということを示すコメントも効果的です。 @// fall through@ など。この特別なコメントは、最後のステートメントグループには必要ありません。

例えば：

<pre>
switch (input) {
 case 1:
 case 2:
 prepareOneOrTwo();
 // fall through
 case 3:
 handleOneTwoOrThree();
 break;
 default:
 handleLargeNumber(input);
}
</pre>

h5. 4.8.4.3 default 節は必要

各スイッチ文はたとえコードがなかったとしても @default@ ステートメントグループが必要です。

h4. 4.8.5 アノテーション

クラス、メソッド、コンストラクタに付けられるアノテーションは、ドキュメンテーションブロックの直後に配置されます。そして、各アノテーションは１行に１個設定されます。これらの改行は行折り返し(4.5 節　行折り返し) に従いません。それ故、インデンテーションレベルも上がりません。例えば：

<pre>
@Override
@Nullable
public String getNameIfPresent() { ... }
</pre>

 *例外：* パラメータ無しのアノテーションが１個だけの場合はシグネチャー行の先頭に来ても良いです。例えば：

<pre>
@Override public int hashCode() { ... }
</pre>

フィールドへのアノテーションもドキュメンテーションブロックの直後です。しかしこの場合、複数のアノテーション(@parameterized など)が同じ行に現れても良いです。例えば：

<pre>
@Partial @Mock DataLoader loader;
</pre>

パラメータや、ローカル変数へのアノテーションについては特にルールはありません。

h4. 4.8.6 コメント

h5. 4.8.6.1 ブロックコメントスタイル

ブロックコメントは周りのコードと同じレベルにインデントされる。 @/* ... */@ でも  @//...@ でも同じである。複数行 @/* ... */@ コメントについては * の位置を先頭行の * と同じに揃えなくてはならない。

<pre>
/*
 * これは         // これも           /* こんなかたち
 * 良い           // 良い              * であっても良い。 */
 */
</pre>

コメントはアスタリスクや他の文字で描かれた箱で囲われることは無い。

bq. *Tip:* 複数行コメントを書く際必要に応じ自動フォーマット機能で行折り返ししたい場合は @/* ... */@ スタイルを使うと良い。多くのフォーマッタは @// ...@ スタイルのコメントの改行を直さない。

h4. 4.8.7 修飾子

クラスやメンバの修飾子はJava言語仕様が推奨する順序で出現しなくてはならない。

<pre>
public protected private abstract static final transient volatile synchronized native strictfp
</pre>


h4. 4.8.8 数値リテラル

long-valued integer literals use an uppercase L suffix, never lowercase (to avoid confusion with the digit 1). For example, 3000000000L rather than 3000000000l.

長い数値リテラルは大文字の @L@ を末尾に使う。小文字は使わない。数値 @1@ との混乱を避ける。例えば @3000000l@ ではなく @300000L@ を使う。

h2. 5 命名

h3. 5.1すべての識別子への共通ルール


識別子はASCII文字のみを使い、数字と大文字小文字とアンダースコアである。
それゆえ、有効な識別子名は正規表現　\w+にマッチする。


Googleスタイルでは、name_, mName, s_name や kName といったような特別な接尾辞・接頭辞は使われない。


h3. 5.2 識別子の種類ごとのルール

h4. 5.2.1 パッケージ名


パッケージ名はすべて小文字で連続する単語をそのまま繋げる。アンダースコアは使わない。
例えば、 @com.example.deepspace@ であって、 @com.example.deepSpace@  や @com.example.deep_space@ は使わない。


h4. 5.2.2 クラス名


クラス名は大文字キャメルケースで命名する。

クラス名は大抵名詞か名詞句です。例えば、 @Character@ や、 @ImmutableList@ です。インターフェース名も名詞か名詞句です。例えば @List@ です。しかし、場合によっては形容詞や形容詞句になります。例えば、 @Readable@ です。

アノテーション型に対する特定のルールや確立した規約はありません。


テストクラスはテスト対象クラス名で始まり、 @Test@ で終わるよう命名されます。例えば @HashTest@ や、 @HashIntegrationTest@ です。


h4. 5.2.3 メソッド名


メソッド名は、小文字キャメルケースで命名されます。

メソッド名は大抵動詞か動詞句です。例えば、sendMessage や stopです。

アンダースコアはJUnitのメソッド名で、論理的コンポーネント名を分離する場合で使ってよいです。
典型的なパターンは　test<MethodUnderTest>_<state>　で、例えば testPop_emptyStackです。
テストメソッドを命名する正しい唯一の方法はありません。


h4. 5.2.4 定数名

定数は コンスタントケースで命名します。すべて大文字で、各単語をアンダースコアで区切ります。しかし定数とは一体何でしょう？

すべての定数はstatic finalなフィールドです。しかし、すべてのstatic finalなフィールドが定数であるとは限りません。
コンスタントケースを選ぶ前に、そのフィールドが定数と感じるか考えてみましょう。例えば、
そのインスタンスの可視な状態が変更できるならば、殆どの場合定数ではありません。
決して変更されないオブジェクトの振りをするだけでは大抵不十分です。例えば、

<pre>
// 定数である
static final int NUMBER = 5;
static final ImmutableList<String> NAMES = ImmutableList.of("Ed", "Ann");
static final Joiner COMMA_JOINER = Joiner.on(',');  // Joiner は不変であるので。
static final SomeMutableType[] EMPTY_ARRAY = {};
enum SomeEnum { ENUM_CONSTANT }

// 定数でない
static String nonFinal = "non-final";
final String nonStatic = "non-static";
static final Set<String> mutableCollection = new HashSet<String>();
static final ImmutableSet<SomeMutableType> mutableElements = ImmutableSet.of(mutable);
static final Logger logger = Logger.getLogger(MyClass.getName());
static final String[] nonEmptyArray = {"these", "can", "change"};
</pre>

これらの名前は大抵名詞か名詞句です。




h4. 5.2.5 定数でないフィールド名

定数でないフィールド名（staticであってもなくても）は小文字キャメルケースで命名されます。

これらの名前は大抵名詞か名詞句です。例えば computedValues や index です。


h4. 5.2.6 パラメータ名

パラメータ名は小文字のキャメルケースです。

一文字のパラメータ名は避けるべきです。

h4. 5.2.7  ローカル変数名

ローカル変数名は小文字キャメルケースで命名されます。他の種類の命名よりも自由に短縮されます。

しかしながら一文字の名前は一時的なループ変数を除いて避けるべきです。

finalで不変であってもローカル変数は定数とは見なされないのでそのようにスタイルされるのは避けるべきです。

h4. 5.2.8 型変数名

型変数名は以下の２つのやり方のうちいずれかで命名されます。

* 一つの大文字アルファベット。それに１個の数字が続いて良い。例：@E, T, X, T2@
* クラスの命名（5.2.2節 クラス名 参照）の後ろに、大文字Tを付加する。例： @RequestT, FooBarT@

h3. 5.3 キャメルケースの定義

"IPv6"や、"iOS"のような頭字語や見慣れない単語があるように、英語のフレーズをキャメルケースに変換する
合理的な方法はいくつかあります。
正確さを維持するため、Google Styleでは以下のように（ほぼ）決定的な方法を定義します。

名前の通常の形から始めて、

# 言葉を素のASCIIに変換し、アポストロフィを除去する。例えば、"Müller's  algorithm" は "Muellers algorithm"に変換される。
# これを単語に分割する。つまり、スペースや残っている句読点、ハイフンで分離する。
** 推奨：もしもある単語が一般的にキャメルケースの形になっていたら、これを分解する。
（例：「AdWords」 を 「ad words」にする。）「iOS」のような単語は本当はキャメルケースになっていない
規約に当てはまらないのでこの推奨は適用しないことに注意する。
# （頭字語を含めて）すべてを小文字にする。そして最初の文字を大文字にする。
** 各単語とは大文字キャメルケースとなるか、最初の単語を除いて小文字キャメルケースになる。
# 最後に、すべての単語を１個の識別子として連結する。

元々の大文字小文字はほぼ無視される。例えば、


|元々の形|正しい変換例|誤った変換例|
|"XML HTTP request"|XmlHttpRequest|XMLHTTPRequest|
|"new customer ID"|newCustomerId|newCustomerID|
|"inner stopwatch"|innerStopwatch|innerStopWatch|
|"supports IPv6 on iOS?"|supportsIpv6OnIos|supportsIPv6OnIOS|
|"YouTube importer"|YouTubeImporter <br> YoutubeImporter [1]||


fn1. やってよいが推奨されない。


h2. 6 Programming Practices プログラミングの実践

h3. 6.1 @Override を常に使う。


A method is marked with the @Override annotation whenever it is legal. This includes a class method overriding a superclass method,
 a class method implementing an interface method, and an interface method respecifying a superinterface method.

許される場所ならばメソッドはOverrideアノテーションをつけられます。これは親クラスのメソッドをオーバーライドするクラスメソッドや、インターフェースのメソッドを実装するクラスのメソッドや、親インターフェースのメソッドを再定義する子インターフェースのメソッドにも当てはまります。

h3. 6.2 キャッチした例外を無視しない。

以下の例外を除き、キャッチした例外に対してなにも対応しないのが正しいことはめったにありません。
大抵の対応はログを取るか、ありえない場合ならばAssertionErrorとして再スローすることです。


キャッチ節でなにもしないことが本当に適切であるならば、それを正当化する理由をコメントで説明します。

<pre>
try {
  int i = Integer.parseInt(response);
  return handleNumericResponse(i);
} catch (NumberFormatException ok) {
  // 数字ではない。このような場合もあるので別の処理を続ける。
}
return handleTextResponse(response);
</pre>


例外：テストにおいて例外がスローされることを期待する場合はキャッチした例外はコメントなしで無視されます。以下の例はテスト対象のメソッドが期待した型の例外をスローすることを確認するためのよくあるイディオムで、コメントは不要です。

<pre>
try {
  emptyStack.pop();
  fail();
} catch (NoSuchElementException expected) {
}
</pre>



h3. 6.3 staticなメンバーはクラスを使って修飾する。

When a reference to a static class member must be qualified, it is qualified with that class's name,
 not with a reference or expression of that class's type.

staticなメンバーへの参照の場合はクラス名で修飾されます。そのクラスの型の変数や式で修飾してはいけません。
(TODO 訳語見直し)

<pre>
Foo aFoo = ...;
Foo.aStaticMethod(); // 良い
aFoo.aStaticMethod(); // 悪い
somethingThatYieldsAFoo().aStaticMethod(); // とても悪い
</pre>


h3. 6.4 ファイナライザは使わない。

Objectクラスのfinalize()メソッドを使うケースは非常に稀です。

TIP: これをやってはいけません。先に Effective JavaのItem7「ファイナライザを避ける」を必ず熟読しなくてはなりません。そしてこれをやってはいけません。




h2. 7 Javadoc 

h3. 7.1 フォーマット

h4. 7.1.1 一般的なフォーマット


The basic formatting of Javadoc blocks is as seen in this example:

Javadocブロックの基本的なフォーマットはこの例で表されます。

<pre>
/**
 * Multiple lines of Javadoc text are written here,
 * wrapped normally...
 */
public int method(String p1) { ... }
</pre>

... or in this single-line example:
一行の例はこれです。

<pre>
/** An especially short bit of Javadoc. */
</pre>

The basic form is always acceptable. The single-line form may be substituted when there are no at-clauses present,
 and the entirety of the Javadoc block (including comment markers) can fit on a single line.

基本的な形は常に適用されます。 @節がない場合や、コメントマーカを含めたJavadocブロック全体において１行で書くほうが体裁が良い場合は
一行の形で代用できます。


h4. 7.1.2 段落


One blank line—that is, a line containing only the aligned leading asterisk (*)—appears between paragraphs, 
and before the group of "at-clauses" if present. Each paragraph but the first has <p> immediately before the first word, with no space after.

１個の空行、つまり、行頭に並べられたアスタリスク(*)のみの行が段落間と@節グループの前に挿入される。
先頭が<p>でないそれぞれの段落は

先頭以外のすべての段落は、最初の単語の前に<p>が入れられる。
(TODO with no space after.の意味は？)


h4. 7.1.3 @節　（javadoc タグ）At-clauses 

（訳注：@param と言った節のこと。参照 http://docs.oracle.com/javase/jp/7/technotes/tools/windows/javadoc.html#javadoctags）
GoogleJavaStyleでしか使っていない用語なので、全部javadoc タグに変えたほうがよいか。）

Any of the standard "at-clauses" that are used appear in the order @param, @return, @throws, @deprecated, 
and these four types never appear with an empty description. When an at-clause doesn't fit on a single line, 
continuation lines are indented four (or more) spaces from the position of the @.

標準の＠節で、使われるものは @param, @return, @throws, @deprecatedの順で現れる。これらの４つは空の記述には現れない。
＠節が１行コメントに収まらない場合、２行目以降は@の位置からスペース４個以上インデントされる。


h3. 7.2 要約の記述


クラスとメンバーのJavadocは簡単な要約の記述から始まります。
この記述はとても重要です。クラスやメソッドの索引のような特別な場所に現れる唯一のテキストだからです。


This is a fragment—a noun phrase or verb phrase, not a complete sentence. 
It does not begin with A {@code Foo} is a..., or This method returns..., nor does it form a complete imperative sentence like Save the record.. 
However, the fragment is capitalized and punctuated as if it were a complete sentence.

この記述は名詞句か動詞句であって文であってはなりません。
「このクラス {@code Foo} は、、、」とか「このメソッドはナニナニを返す。」で始まってはいけませんし、「結果を保存する。」といった
命令文でもいけません。しかしながらこの記述はあたかも文であるかのように大文字化され、句読点が付けられます。
（TODO 訳見直し）

Tip: A common mistake is to write simple Javadoc in the form /** @return the customer ID */. 
This is incorrect, and should be changed to /** Returns the customer ID. */.

TIP: /** @return the customer ID */といった簡単なJavadocを書くことはよくある間違いです。
これは不正で、正しくは以下のように直されるべきです。/** Returns the customer ID. */.




h3. 7.3 Where Javadoc is used Javadocが使われる場所

少なくとも、javadocはpublicなクラスとそのクラスのpublic protected なメンバーに書かれます。但し以下の例外が有ります。

h4. 7.3.1 Exception: self-explanatory methods 例外　自己叙述的なメソッド。

javadocはgetFooのような簡単で明確なメソッドの場合は必須ではありません。つまり、「fooを返す」以外の意味ある情報が本当に無い場合です。


The test methods of a unit test class are perhaps the most common example of this exemption. These methods can usually be named descriptively enough that no additional documentation is needed.


ユニットテストクラスのテストメソッドはおそらくこの例外の最も一般的な例外です。このようなメソッドは他の追加の文書が不要なほど内容がわかるように命名されます。


Tip: Important: it is not appropriate to cite this exception to justify omitting relevant information that a typical reader might need to know. For example, for a method named getCanonicalName, don't omit its documentation (with the rationale that it would say only /** Returns the canonical name. */) if a typical reader may have no idea what the term "canonical name" means!

Tip: 重要：この例外を典型的な読者が知りたがるような関連情報を省略することを正当化するために引用するのは
適切ではありません。例えば、「getCanonicalName」というメソッドにおいて典型的な読者が「canonical name」という語の意味を
知らないかもしれない場合、（単に/** Returns the canonical name. */と書くだけであるという理由で）省略してはいけません。




h4. 7.3.2  例外　オーバーライドするメソッド

親クラスのメソッドをオーバーライドするメソッドについてはJavadocは必須ではありません。


h4. 7.3.3 追加のjavadoc

パッケージ外から可視でないクラスやメンバーでもJavadocは必要です。クラス・メソッド・フィールドの挙動や全体的な目的を定める時実装コメントが必要な場合は、そのコメントはJavadocで書かれます。（より統一的で、ツールとの親和性も高いです。）



