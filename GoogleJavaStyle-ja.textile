
h1. Google Java Style (和訳)


--------------
h2. この文書について

本文書は、 [Google Java Style](http://google-styleguide.googlecode.com/svn/trunk/javaguide.html) の非公式和訳です。
技術的に正確である事を意図して訳してありますが、どこかで間違えているかもしれません。
さらに言えば翻訳作業途中です。生暖かく見守ってやってください。
誤訳、誤植の指摘を歓迎いたします。

--------------


h2. 1 導入

この文書はJavaプログラミング言語のソースコードのGoogleのコーディング標準の完全な定義を提供する。
下記のルールに従うJavaソースファイルのみが、Googleスタイルであるとみなされる。


Like other programming style guides, the issues covered span not only aesthetic issues of formatting,
 but other types of conventions or coding standards as well.
  However, this document focuses primarily on the hard-and-fast rules that we follow universally,
   and avoids giving advice that isn't clearly enforceable (whether by human or tool). 

他のプログラミングスタイルガイドのように、問題の対象範囲は審美的なフォーマットの問題だけでなく
他の種類の規約やコーディング標準も含まれる。
しかしながら、この文書は私達が全世界的に従う当然の規則に優先的に注力していて、
（人間でもマシンでも）明確に実施できない助言をすることを避けている。


h3. 1.1 用語についての注記


In this document, unless otherwise clarified:

    The term class is used inclusively to mean an "ordinary" class, enum class, interface 
    or annotation type (@interface).
    The term comment always refers to implementation comments. 
    We do not use the phrase "documentation comments", instead using the common term "Javadoc."

Other "terminology notes" will appear occasionally throughout the document.


本文書において、特別に断りのない限り、

1. クラスという用語は、「通常の」クラス、列挙型  、インターフェース、アノテーション型(@interface)を包括的に意味する。

2. コメントという用語は、常に実装のコメントを意味する。「ドキュメンテーションコメント」という言い方は使わない。
代わりに共通的に使われている、「Javadoc」という言葉を使う。

他の、用語の注記はこの文書を通じて現れる。



h3. 1.2 ガイドについての注記

Example code in this document is non-normative. 
That is, while the examples are in Google Style, they may not illustrate the only 
stylish way to represent the code. 
Optional formatting choices made in examples should not be enforced as rules.

この文書内のサンプルコードは規約に従っていない。
つまり、サンプルコードはGoogleスタイルであるが、コードを表現する唯一のスタイルに則った
やり方を説明していないかもしれない。
サンプルコードの追加の整形のやり方はルールとして強調されるべきではない。

（ TODO 約見直し）

h2. 2 ソースファイルの基本

h3.  2.1 ファイル名



The source file name consists of the case-sensitive name of the top-level class it contains, 
plus the .java extension.

ソースファイル名はそれが入っているトップレベルクラスの大文字小文字を区別した名前と加えて.java
という拡張子が付いていること。


### 2.2 ファイルエンコーディング：UTF-8

ソースファイルはUTF-8でエンコードされていること。


### 2.3 特殊文字


#### 2.3.1 空白

行区切り文字以外では、ASCII水平スペース文字 (0x20) はソース内でどこに現れても良い唯一の空白文字です。
つまり、

1. Stringと文字リテラルでのこれ以外の空白文字はエスケープされること。
2. タブ文字をインデントの目的で使ってはいけない。

ことを意味します。


#### 2.3.2 特殊文字シーケンス

特殊なエスケープシーケンスを持つ全ての文字(\b, \t, \n, \f, \r, \", \' と \\\\)については
8進数表記(\\012)やUnicodeエスケープ(\\u000a)でなく、通常のエスケープシーケンスで表記する。



#### 2.3.3 非ASCII文字

残りの非ASCII文字については
ソースコードを読むことや理解することが簡単になるかどうかのみを基準にして
実際のUnicode文字（例：∞）あるいは同等のUnicodeエスケープ(例： \\u221e)を使うかの判断を行う。


> TIP: Unicodeエスケープの場合、時たま実際にUnicode文字が使われている時でも説明のコメントがあるとわかりやすいです。



テーブルどうする？




> TIP: 単に何かのプログラムが非ASCII文字を正しく処理しないからといってコードを読みにくくしないで下さい。もしそのような事が起こる場合はそのプログラムがおかしいのであってプログラムが修正されるべきです。


## 3 ソースファイル構造


ソースファイルの内容は以下の順序であること。

1. ライセンスあるいはコピーライトの情報（もしあるならば）
2. package文
3. import文
4. ただ1個のトップレベルクラス。

それぞれの分離には、ただ1個の空行を使うこと。


### 3.1 ライセンスあるいはコピーライトの情報（もしあるならば）


もしファイルにライセンスあるいはコピーライトの情報があるならばここに入る。

### 3.2 パッケージ文

パッケージ文は**行折り返ししてはならない**。文字数制限（4.4節文字数制限は80あるいは100文字）はパッケージ文には適用されない。

### 3.3 インポート文
#### 3.3.1 ワイルドカードインポートは禁止

ワイルドカードインポートはstatic出会ってもなくても使ってはならない。

#### 3.3.2 改行禁止

import文は**改行してはならない。**　文字数制限（4.4節文字数制限は80あるいは100文字）はimport文には適用されない。


#### 3.3.3 順序と空白


インポート文は以下のグループに以下の順序で分けられる。グループは1行の空白で分離される。

1. すべてのstatic importを単一のグループにまとめる。
2. com.google のインポート。（ソースファイルがcom.googleパッケージに属する場合のみ）
3. サードパーティのインポート。トップレベルパッケージ毎に1個のグループとしASCII文字の順序で
例：android, com, junit, org, sun
4. java パッケージのインポート
5. javax パッケージのインポート


空行が無いグループ毎にインポートした名前はASCII順に並べなければならない。
（注釈：これはセミコロンの存在がソート結果を変えてしまうという意味でインポート文がASCII順になっていることと同じではない。）

### 3.4 クラス宣言

#### 3.4.1 正確に1個のトップレベルクラスの宣言

各トップレベルクラスは1個のファイルに保存される。

#### 3.4.2 クラスメンバーの順序

クラスメンバーの順序はわかりやすさに多大な影響を与えるが唯一の解法は無い。
クラス毎にメンバーの並びが異なっていて良い。



重要な事はそれぞれのクラスはメンバーを質問された時に答えられるような論理的な順序で並べることである。
例えば新しいメソッドは追加された日を表すようにクラスの最後に考えもなしに追加されてはならない。
それは論理的ではない。

TODO 要推敲

##### 3.4.2.1 オーバーロードを分離してはならない

クラスに複数のコンストラクタや同じ名前を持つメソッドがある場合は連続して並べる。
間に別のメンバーを入れてはならない。


## 4 フォーマット

用語についての注釈：ブロックのような構造物とは、クラス、メソッド、コンストラクタの本体を指す。
すべての配列は必要に応じてブロックのような構造物とみなされて良い。4.8.3.1節 配列初期化子を参照。

### 4.1 中括弧

#### 4.1.1 使えるところでは中括弧は使う

括弧は if else for do while 文において本体が空でも1行しかなくても使われる。


#### 4.1.2 空でないブロックではK&Rスタイルに従う。


中括弧は空でないブロックや、ブロックのような構造物ではカーニハン・リッチースタイル( Egyptian Brackets)に従う。


* 開始中括弧の前に改行を入れない。
* 開始中括弧の後に改行を入れる。
* 終了中括弧の前に改行を入れる。
* もし終了中括弧が文やメソッドの本体を終えるならばその中括弧の後に改行を入れる。例えば終了中括弧の後にelseや、カンマが続く場合は改行をしない。

例：

<pre><code class="java">
return new MyClass() {
  @Override public void method() {
    if (condition()) {
      try {
        something();
      } catch (ProblemException e) {
        recover();
      }
    }
  }
};
</code></pre>

列挙型でのいくつかの例外はセクション4.8.1 列挙型にて示される。


#### 4.1.3 空ブロックは簡潔に



An empty block or block-like construct may be closed immediately after it is opened, with no characters or line break in between ({}), unless it is part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else or try/catch/finally).



空ブロックや空のブロックのような構造物は開始括弧直後に文字や改行無しで閉じてよい。（{}）
但し、if/else-if/else あるいは try/catch/finallyのような複数ブロックの文の場合を除く。

例：

<pre>
void doNothing() {} 
</pre>


### 4.2 ブロックのインデントは空白2個である。


新しいブロックあるいはブロック構造物が開始した時インデントは空白2個づつ増える。
ブロックが終了したら、インデントは1個まえのレベルに戻る。
インデントレベルはブロックを通じてコードとコメントに適用される。4.1.2節の例を参照のこと。
（ 4.1.2 空でないブロックではK&Rスタイルに従う。）



### 4.3 1行毎に1個の文

各文は、末尾に改行が来なくてはならない。

### 4.4 1行の文字数制限。　80文字か100文字


プロジェクトごとに1行の文字数制限を80文字か100文字から自由に決定して良い。
以下の例外を除き、この制限を超えた行は4.5節で述べるように改行されなくてはならない。

例外：


1. 文字数制限に従うのが不可能の場合。（例えば、Javadoc内の長いURL、長いJSNIメソッド参照）
2. パッケージ文とインポート文　（3.2 パッケージ文　と3.3 インポート文を参照のこと）
3. コメント内の、コンソールにコピー＆ペーストされるようなコマンド。

### 4.5 行の折り返し

用語の注記：別の意味で正当に単一行を占めているコードを複数行に分けるとき、
通常は文字数制限を超えないように分ける。この活動を行の折り返しと呼ぶ。


どんな状況にも合う改行方法を正確に示す、統一的で決定的なやり方はありません。
同じコード片を改行する正しい方法は複数あるものです。


TIP:　メソッドやローカル変数の抽出は改行をせずに問題を解決する場合があります。


#### 4.5.1 どこで改行するか


改行の第一原則は、高い文法のレベルで改行することです。つまり、



1. 代入でない演算子で改行するときは、シンボルの前で改行します。（これはJavaScriptやC++のような他の
言語でのGoogleスタイルで使われている週間と同じであることに注意して下さい）
このことはドット演算子( . )や、型演算子の＆記号( <T extends Foo & Bar> )や、
catch節でのパイプ記号 (catch (FooException | BarException e)).といった演算子のようなシンボルにも
適用されます。
2. 行が代入演算子で改行されるときは、通常シンボルの後ろで改行します。しかしどちらでも受け入れられます。
このことは拡張 ("foreach") 文の「代入演算子のような」コロンにも適用されます。
3. メソッドやコンストラクタ名に続く開始括弧（(）は改行されません。
4. カンマ(,)はそれの前のトークンに続いて書かれます。改行されません。

h4. 4.5.2 インデントが続く行は最低4個の空白です。

改行の際、連続する先頭行後の各行は少なくとも空白4個分元からインデントされます。


複数の連続した行がある場合、インデントは4以上ならいくつでも良いです。
一般的に、2個の連続した行が同じインデントレベルであるならばその時のみ、
文法的並行した要素で始まるべきです。
（意味不明。。。）

4.6.3節の、水平アラインメントは
もっとわけわかめ


h3. 4.6 空白

h4. 4.6.1 垂直の空白

単一の空行が生成される状況は以下のとおり。

1. クラスの連続するメンバ（あるいは初期化子）の間。フィールド、コンストラクタ、メソッド、ネストしたクラス、static初期化子、インスタンス初期化子
例外：2個の連続するフィールド（その間にコードがないもの）間での空行は任意である。そのような空行はフィールドの論理的なグループ分けをするのに必要。

2. メソッド本体内で、文を論理的にグループ分けしたい場合。
3. 入れたいならば、クラスの最初のメンバーの前と最終メンバーの後。（推奨も拒否もしない）
4. 本文書の別の節で入れるよう求められた場所（3.3節のインポート文など）

複数の連続した空行を入れて良いが、必須でも推奨でもない。


h4. 4.6.2 水平の空白



言語かあるいは他のスタイルルールの要求であるかによらず、
リテラル、コメント、Javadoc以外で1個のASCII空白は以下の場所
**のみ**において使って良い。

1. 予約語（if, for , catch）とその行での開始小括弧 (()の間。
2. 予約語（else, catch）とその行での前に来る終了中括弧(})との間。
3. 開始中括弧({)の前すべて。ただし以下の2個の例外を除く
* @SomeAnnotation({a, b}) (空白は使わない。)
* String[][] x = {{"foo"}};　({{ の中に空白は不要。項目8を参照)
4. すべてのバイナリ、tenary演算子の両側。また、以下の様な演算子ライクなシンボルにも適用する。
* 連続する型パラメータ間のアンパサンド。　<T extends Foo & Bar>


h4. 4.6.3 Horizontal alignment: never required 

水平位置の揃え　全く不要




Terminology Note: Horizontal alignment is the practice of adding a variable number of additional spaces in your code with the goal of making certain tokens appear directly below certain other tokens on previous lines.
用語の注釈
水平位置の揃えは前の行のあるトークンの真下にトークンが来るようにコードに追加のすペースを幾つか入れるやり方のことです。　　実践ノ事です



This practice is permitted, but is never required by Google Style. It is not even required to maintain horizontal alignment in places where it was already used.
これはやって良いがGoogleスタイルでは要求されない。すでに為されているところをそのように維持することすら求めれられない




Here is an example without alignment, then using alignment:
これはやっている例とやっていない例です。

private int x; // this is fine
private Color color; // this too

これはok  これも

private int   x;      // permitted, but future edits
private Color color;  // may leave it unaligned

やって良いがあとで直されるかもしれない

Tip: Alignment can aid readability, but it creates problems for future maintenance. Consider a future change that needs to touch just one line. This change may leave the formerly-pleasing formatting mangled, and that is allowed.
調整は可読性を上げるが将来のメンテナンスで問題になる。一行だけ直したいときをかんがえてほしい
この変更は以前のきれいな並びをおかしくする。そしてそうなる




More often it prompts the coder (perhaps you) to adjust whitespace on nearby lines as well, possibly triggering a cascading series of reformattings. このことはコーダー多分君に近くの行に同様になおせと求める。そして修正範囲の拡大を引き起こす



That one-line change now has a "blast radius." This can at worst result in pointless busywork, but at best it still corrupts version history information, slows down reviewers and exacerbates merge conflicts.
一行の偏向が核爆発に為る。最悪意味のない作業になる。良くても変更履歴を汚くする。レビューがおそく成り、マージの衝突が激増する。



h3. 4.7 Grouping parentheses: recommended 

グループ化の括弧　　推奨

Optional grouping parentheses are omitted only when author and reviewer agree that there is no reasonable 
chance the code will be misinterpreted without them, nor would they have made the code easier to read. 
It is not reasonable to assume that every reader has the entire Java operator precedence table memorized.

追加のグループ化の括弧は作者とレビュアーが括弧なしでもコードは誤解される余地がないと
認めるか、コードを読みやすく書いた時のみなくすことが出来ます。すべての読者がJava演算子の優先度表を
記憶していると仮定するのは合理的でありません。







h3. 4.8 Specific constructs 
各構造物

h4. 4.8.1 Enum classes 
列挙型

After each comma that follows an enum constant, a line-break is optional.
列挙定数値後のカンマの後ろの改行は任意である


An enum class with no methods and no documentation on its constants may optionally be formatted as if it were an array initializer:
定数値にメソッドもドキュメンテーションもない列挙型は任意に配列の初期化と同じやり方で整形してよい。

private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }
Since enum classes are classes, all other rules for formatting classes apply.
列挙型はclassであるのでクラスに適用されるほかのルールが適用される。
h4. 4.8.2 Variable declarations 
値の宣言
h5. 4.8.2.1 One variable per declaration 
宣言ごとに一個の変数

Every variable declaration (field or local) declares only one variable: declarations such as int a, b; are not used.
フィールドでもローカル変数でも変数宣言は一個だけの変数を宣言する。　　のような宣言は使われない。
h5. 4.8.2.2 Declared when needed, initialized as soon as possible 
必要なときに宣言して
速やかに初期化する
Local variables are not habitually declared at the start of their containing block or block-like construct. Instead, local variables are declared close to the point they are first used (within reason), to minimize their scope.
ローカル変数はそれを含むブロックやブロック構造物の先頭でハビチュアリに宣言されてはならない。代わりに、ローカル変数はそのスコープを最小化するために最初に使う場所(理由がある)の近くで宣言される。


 Local variable declarations typically have initializers, or are initialized immediately after declaration.

ローカル変数宣言は形式的に初期化子がある。あるいは宣言直後に初期化される。

h4. 4.8.3 Arrays 
配列
h5. 4.8.3.1 Array initializers: can be "block-like" 
配列の初期化はブロックのようにやって良い。
Any array initializer may optionally be formatted as if it were a "block-like construct." For example, the following are all valid (not an exhaustive list):
配列の初期化はあたかもブロック構造物のようにやって良い。例えば以下の例は総べて有効である。網羅的なリストでは無い。

new int[] {           new int[] {
  0, 1, 2, 3            0,
}                       1,
                        2,
new int[] {             3,
  0, 1,               }
  2, 3
}                     new int[]
                          {0, 1, 2, 3}

h5. 4.8.3.2 No C-style array declarations 
Cのような宣言は禁止

The square brackets form a part of the type, not the variable: String[] args, not String args[].
角括弧は型の一部を為すが、変数には当てはまらない。　String[] args は良い。 String args[]　はダメ。


h4. 4.8.4 Switch statements 
スイッチ文




