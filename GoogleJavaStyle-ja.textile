h1. Google Java Style (和訳)


--------------
h2. この文書について

本文書は、"Google Java Style":http://google-styleguide.googlecode.com/svn/trunk/javaguide.html の非公式和訳です。
技術的に正確である事を意図して訳してありますが、どこかで間違えているかもしれません。
さらに言えば翻訳作業途中です。生暖かく見守ってやってください。
誤訳、誤植の指摘を歓迎いたします。

--------------


h2. 1 導入

この文書はJavaプログラミング言語のソースコードのGoogleのコーディング標準の *完全* な定義を提供する。
下記のルールに従うJavaソースファイルのみが、Googleスタイルであるとみなされる。


Like other programming style guides, the issues covered span not only aesthetic issues of formatting,
 but other types of conventions or coding standards as well.
  However, this document focuses primarily on the hard-and-fast rules that we follow universally,
   and avoids giving advice that isn't clearly enforceable (whether by human or tool). 

他のプログラミングスタイルガイドのように、問題の対象範囲は審美的なフォーマットの問題だけでなく
他の種類の規約やコーディング標準も含まれる。
しかしながら、この文書は私達が全世界的に従う *当然の規則* に優先的に注力していて、
（人間でもマシンでも）明確に実施できない助言をすることを避けている。


h3. 1.1 用語についての注記


In this document, unless otherwise clarified:

    The term class is used inclusively to mean an "ordinary" class, enum class, interface 
    or annotation type (@interface).
    The term comment always refers to implementation comments. 
    We do not use the phrase "documentation comments", instead using the common term "Javadoc."

Other "terminology notes" will appear occasionally throughout the document.


本文書において、特別に断りのない限り、

# クラスという用語は、「通常の」クラス、列挙型  、インターフェース、アノテーション型(@interface)を包括的に意味する。
# コメントという用語は、常に実装のコメントを意味する。「ドキュメンテーションコメント」という言い方は使わない。代わりに共通的に使われている、「Javadoc」という言葉を使う。


他ものへの用語の注記はこの文書を通じて現れる。



h3. 1.2 ガイドについての注記

Example code in this document is non-normative. 
That is, while the examples are in Google Style, they may not illustrate the only 
stylish way to represent the code. 
Optional formatting choices made in examples should not be enforced as rules.

この文書内のサンプルコードは規約に *従っていない。* 
つまり、サンプルコードはGoogleスタイルであるが、コードを表現する唯一のスタイルに則った
やり方を説明していないかもしれない。サンプルコードの追加の整形のやり方はルールとして強調されるべきではない。

h2. 2 ソースファイルの基本

h3.  2.1 ファイル名



The source file name consists of the case-sensitive name of the top-level class it contains, 
plus the .java extension.

ソースファイル名はそれが入っているトップレベルクラスの大文字小文字を区別した名前と加えて @.java@
という拡張子が付いていること。


h3. 2.2 ファイルエンコーディング：UTF-8

ソースファイルはUTF-8でエンコードされていること。


.h3 2.3 特殊文字

.h4 2.3.1 空白

行区切り文字以外では、ASCII水平スペース文字 (0x20) はソース内でどこに現れても良い唯一の空白文字です。
つまり、

# Stringと文字リテラルでのこれ以外の空白文字はエスケープされること。
# タブ文字をインデントの目的で *使ってはいけない。*

ことを意味します。


.h4 2.3.2 特殊文字シーケンス

特殊なエスケープシーケンスを持つ全ての文字(\b, \t, \n, \f, \r, \", \' と \\\\)については
8進数表記(\\012)やUnicodeエスケープ(\\u000a)でなく、通常のエスケープシーケンスで表記する。


.h4 2.3.3 非ASCII文字

残りの非ASCII文字については *ソースコードを読むことや理解することが簡単になる* かどうかのみを基準にして
実際のUnicode文字（例：∞）あるいは同等のUnicodeエスケープ(例： \\u221e)を使うかの判断を行う。


TIP: Unicodeエスケープの場合、時たま実際にUnicode文字が使われている時でも説明のコメントがあるとわかりやすいです。



テーブルどうする？

|例                           |説明|
|String unitAbbrev = "μs";                             |最高。コメントなしでも完全に明確|
|String unitAbbrev = "\u03bcs"; // "μs"                |許容される。しかしこれをする理由はない。|
|String unitAbbrev = "\u03bcs"; // ギリシャ文字ミューと "s" |許容される。しかし奇妙で間違えやすい|
|String unitAbbrev = "\u03bcs";                         |だめ。読者やこれが何なのか分からない。|
|return '\ufeff' + content; // バイトオーダーマーク     |良い。表示されない文字にはエスケープを使い、必要ならコメントする。|



> TIP: 単に何かのプログラムが非ASCII文字を正しく処理しないからといってコードを読みにくくしないで下さい。もしそのような事が起こる場合はそのプログラムがおかしいのであってプログラムが修正されるべきです。


## 3 ソースファイル構造


ソースファイルの内容は以下の順序であること。

1. ライセンスあるいはコピーライトの情報（もしあるならば）
2. package文
3. import文
4. ただ1個のトップレベルクラス。

それぞれの分離には、ただ1個の空行を使うこと。


### 3.1 ライセンスあるいはコピーライトの情報（もしあるならば）


もしファイルにライセンスあるいはコピーライトの情報があるならばここに入る。

### 3.2 パッケージ文

パッケージ文は**行折り返ししてはならない**。文字数制限（4.4節文字数制限は80あるいは100文字）はパッケージ文には適用されない。

### 3.3 インポート文
#### 3.3.1 ワイルドカードインポートは禁止

ワイルドカードインポートはstatic出会ってもなくても使ってはならない。

#### 3.3.2 改行禁止

import文は**改行してはならない。**　文字数制限（4.4節文字数制限は80あるいは100文字）はimport文には適用されない。


#### 3.3.3 順序と空白


インポート文は以下のグループに以下の順序で分けられる。グループは1行の空白で分離される。

1. すべてのstatic importを単一のグループにまとめる。
2. com.google のインポート。（ソースファイルがcom.googleパッケージに属する場合のみ）
3. サードパーティのインポート。トップレベルパッケージ毎に1個のグループとしASCII文字の順序で
例：android, com, junit, org, sun
4. java パッケージのインポート
5. javax パッケージのインポート


空行が無いグループ毎にインポートした名前はASCII順に並べなければならない。
（注釈：これはセミコロンの存在がソート結果を変えてしまうという意味でインポート文がASCII順になっていることと同じではない。）

### 3.4 クラス宣言

#### 3.4.1 正確に1個のトップレベルクラスの宣言

各トップレベルクラスは1個のファイルに保存される。

#### 3.4.2 クラスメンバーの順序

クラスメンバーの順序はわかりやすさに多大な影響を与えるが唯一の解法は無い。
クラス毎にメンバーの並びが異なっていて良い。



重要な事はそれぞれのクラスはメンバーを質問された時に答えられるような論理的な順序で並べることである。
例えば新しいメソッドは追加された日を表すようにクラスの最後に考えもなしに追加されてはならない。
それは論理的ではない。

TODO 要推敲

##### 3.4.2.1 オーバーロードを分離してはならない

クラスに複数のコンストラクタや同じ名前を持つメソッドがある場合は連続して並べる。
間に別のメンバーを入れてはならない。


h2. 4 フォーマット

用語についての注釈：ブロックのような構造物とは、クラス、メソッド、コンストラクタの本体を指す。
すべての配列は必要に応じてブロックのような構造物とみなされて良い。4.8.3.1節 配列初期化子を参照。

h3. 4.1 中括弧

#### 4.1.1 使えるところでは中括弧は使う

括弧は if else for do while 文において本体が空でも1行しかなくても使われる。


#### 4.1.2 空でないブロックではK&Rスタイルに従う。


中括弧は空でないブロックや、ブロックのような構造物ではカーニハン・リッチースタイル( Egyptian Brackets)に従う。


* 開始中括弧の前に改行を入れない。
* 開始中括弧の後に改行を入れる。
* 終了中括弧の前に改行を入れる。
* もし終了中括弧が文やメソッドの本体を終えるならばその中括弧の後に改行を入れる。例えば終了中括弧の後にelseや、カンマが続く場合は改行をしない。

例：

<pre><code class="java">
return new MyClass() {
  @Override public void method() {
    if (condition()) {
      try {
        something();
      } catch (ProblemException e) {
        recover();
      }
    }
  }
};
</code></pre>

列挙型でのいくつかの例外はセクション4.8.1 列挙型にて示される。


#### 4.1.3 空ブロックは簡潔に



An empty block or block-like construct may be closed immediately after it is opened, with no characters or line break in between ({}), unless it is part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else or try/catch/finally).



空ブロックや空のブロックのような構造物は開始括弧直後に文字や改行無しで閉じてよい。（{}）
但し、if/else-if/else あるいは try/catch/finallyのような複数ブロックの文の場合を除く。

例：

<pre>
void doNothing() {} 
</pre>


### 4.2 ブロックのインデントは空白2個である。


新しいブロックあるいはブロック構造物が開始した時インデントは空白2個づつ増える。
ブロックが終了したら、インデントは1個まえのレベルに戻る。
インデントレベルはブロックを通じてコードとコメントに適用される。4.1.2節の例を参照のこと。
（ 4.1.2 空でないブロックではK&Rスタイルに従う。）



### 4.3 1行毎に1個の文

各文は、末尾に改行が来なくてはならない。

### 4.4 1行の文字数制限。　80文字か100文字


プロジェクトごとに1行の文字数制限を80文字か100文字から自由に決定して良い。
以下の例外を除き、この制限を超えた行は4.5節で述べるように改行されなくてはならない。

例外：


1. 文字数制限に従うのが不可能の場合。（例えば、Javadoc内の長いURL、長いJSNIメソッド参照）
2. パッケージ文とインポート文　（3.2 パッケージ文　と3.3 インポート文を参照のこと）
3. コメント内の、コンソールにコピー＆ペーストされるようなコマンド。

### 4.5 行の折り返し

用語の注記：別の意味で正当に単一行を占めているコードを複数行に分けるとき、
通常は文字数制限を超えないように分ける。この活動を行の折り返しと呼ぶ。


どんな状況にも合う改行方法を正確に示す、統一的で決定的なやり方はありません。
同じコード片を改行する正しい方法は複数あるものです。


TIP:　メソッドやローカル変数の抽出は改行をせずに問題を解決する場合があります。


#### 4.5.1 どこで改行するか


改行の第一原則は、高い文法のレベルで改行することです。つまり、



1. 代入でない演算子で改行するときは、シンボルの前で改行します。（これはJavaScriptやC++のような他の
言語でのGoogleスタイルで使われている週間と同じであることに注意して下さい）
このことはドット演算子( . )や、型演算子の＆記号( <T extends Foo & Bar> )や、
catch節でのパイプ記号 (catch (FooException | BarException e)).といった演算子のようなシンボルにも
適用されます。
2. 行が代入演算子で改行されるときは、通常シンボルの後ろで改行します。しかしどちらでも受け入れられます。
このことは拡張 ("foreach") 文の「代入演算子のような」コロンにも適用されます。
3. メソッドやコンストラクタ名に続く開始括弧（(）は改行されません。
4. カンマ(,)はそれの前のトークンに続いて書かれます。改行されません。

h4. 4.5.2 インデントが続く行は最低4個の空白です。

改行の際、連続する先頭行後の各行は少なくとも空白4個分元からインデントされます。


複数の連続した行がある場合、インデントは4以上ならいくつでも良いです。
一般的に、2個の連続した行が同じインデントレベルであるならばその時のみ、
文法的並行した要素で始まるべきです。
（意味不明。。。）

4.6.3節の、水平アラインメントは
もっとわけわかめ


h3. 4.6 空白

h4. 4.6.1 垂直の空白

単一の空行が生成される状況は以下のとおり。

1. クラスの連続するメンバ（あるいは初期化子）の間。フィールド、コンストラクタ、メソッド、ネストしたクラス、static初期化子、インスタンス初期化子
例外：2個の連続するフィールド（その間にコードがないもの）間での空行は任意である。そのような空行はフィールドの論理的なグループ分けをするのに必要。

2. メソッド本体内で、文を論理的にグループ分けしたい場合。
3. 入れたいならば、クラスの最初のメンバーの前と最終メンバーの後。（推奨も拒否もしない）
4. 本文書の別の節で入れるよう求められた場所（3.3節のインポート文など）

複数の連続した空行を入れて良いが、必須でも推奨でもない。


h4. 4.6.2 水平の空白



言語かあるいは他のスタイルルールの要求であるかによらず、
リテラル、コメント、Javadoc以外で1個のASCII空白は以下の場所
**のみ**において使って良い。

1. 予約語（if, for , catch）とその行での開始小括弧 (()の間。
2. 予約語（else, catch）とその行での前に来る終了中括弧(})との間。
3. 開始中括弧({)の前すべて。ただし以下の2個の例外を除く
* @SomeAnnotation({a, b}) (空白は使わない。)
* String[][] x = {{"foo"}};　({{ の中に空白は不要。項目8を参照)
4. すべてのバイナリ、tenary演算子の両側。また、以下の様な演算子ライクなシンボルにも適用する。
* 連続する型パラメータ間のアンパサンド。　<T extends Foo & Bar>


h4. 4.6.3 Horizontal alignment: never required 

水平位置の揃え　全く不要




Terminology Note: Horizontal alignment is the practice of adding a variable number of additional spaces in your code with the goal of making certain tokens appear directly below certain other tokens on previous lines.
用語の注釈
水平位置の揃えは前の行のあるトークンの真下にトークンが来るようにコードに追加のすペースを幾つか入れるやり方のことです。　　実践ノ事です



This practice is permitted, but is never required by Google Style. It is not even required to maintain horizontal alignment in places where it was already used.
これはやって良いがGoogleスタイルでは要求されない。すでに為されているところをそのように維持することすら求めれられない


Here is an example without alignment, then using alignment:
これはやっている例とやっていない例です。

<pre>
private int x; // this is fine
private Color color; // this too
</pre>

これはok  これも

<pre>
private int   x;      // permitted, but future edits
private Color color;  // may leave it unaligned
</pre>

やって良いがあとで直されるかもしれない

Tip: Alignment can aid readability, but it creates problems for future maintenance. Consider a future change that needs to touch just one line. This change may leave the formerly-pleasing formatting mangled, and that is allowed.
調整は可読性を上げるが将来のメンテナンスで問題になる。一行だけ直したいときをかんがえてほしい
この変更は以前のきれいな並びをおかしくする。そしてそうなる




More often it prompts the coder (perhaps you) to adjust whitespace on nearby lines as well, possibly triggering a cascading series of reformattings. このことはコーダー多分君に近くの行に同様になおせと求める。そして修正範囲の拡大を引き起こす



That one-line change now has a "blast radius." This can at worst result in pointless busywork, but at best it still corrupts version history information, slows down reviewers and exacerbates merge conflicts.
一行の偏向が核爆発に為る。最悪意味のない作業になる。良くても変更履歴を汚くする。レビューがおそく成り、マージの衝突が激増する。



h3. 4.7 Grouping parentheses: recommended 

グループ化の括弧　　推奨

Optional grouping parentheses are omitted only when author and reviewer agree that there is no reasonable 
chance the code will be misinterpreted without them, nor would they have made the code easier to read. 
It is not reasonable to assume that every reader has the entire Java operator precedence table memorized.

追加のグループ化の括弧は作者とレビュアーが括弧なしでもコードは誤解される余地がないと
認めるか、コードを読みやすく書いた時のみなくすことが出来ます。すべての読者がJava演算子の優先度表を
記憶していると仮定するのは合理的でありません。







h3. 4.8 Specific constructs 

各構造物

h4. 4.8.1 Enum classes 

列挙型

After each comma that follows an enum constant, a line-break is optional.
列挙定数値後のカンマの後ろの改行は任意である


An enum class with no methods and no documentation on its constants may optionally be formatted as if it were an array initializer:
定数値にメソッドもドキュメンテーションもない列挙型は任意に配列の初期化と同じやり方で整形してよい。

private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }
Since enum classes are classes, all other rules for formatting classes apply.
列挙型はclassであるのでクラスに適用されるほかのルールが適用される。

h4. 4.8.2 Variable declarations 

値の宣言

h5. 4.8.2.1 One variable per declaration 

宣言ごとに一個の変数

Every variable declaration (field or local) declares only one variable: declarations such as int a, b; are not used.
フィールドでもローカル変数でも変数宣言は一個だけの変数を宣言する。　　のような宣言は使われない。

h5. 4.8.2.2 Declared when needed, initialized as soon as possible 

必要なときに宣言して
速やかに初期化する
Local variables are not habitually declared at the start of their containing block or block-like construct. Instead, local variables are declared close to the point they are first used (within reason), to minimize their scope.
ローカル変数はそれを含むブロックやブロック構造物の先頭でハビチュアリに宣言されてはならない。代わりに、ローカル変数はそのスコープを最小化するために最初に使う場所(理由がある)の近くで宣言される。


 Local variable declarations typically have initializers, or are initialized immediately after declaration.

ローカル変数宣言は形式的に初期化子がある。あるいは宣言直後に初期化される。

h4. 4.8.3 Arrays 

配列

h5. 4.8.3.1 Array initializers: can be "block-like" 
配列の初期化はブロックのようにやって良い。
Any array initializer may optionally be formatted as if it were a "block-like construct." For example, the following are all valid (not an exhaustive list):
配列の初期化はあたかもブロック構造物のようにやって良い。例えば以下の例は総べて有効である。網羅的なリストでは無い。

<pre>
new int[] {           new int[] {
  0, 1, 2, 3            0,
}                       1,
                        2,
new int[] {             3,
  0, 1,               }
  2, 3
}                     new int[]
                          {0, 1, 2, 3}
</pre>


h5. 4.8.3.2 No C-style array declarations 
Cのような宣言は禁止

The square brackets form a part of the type, not the variable: String[] args, not String args[].
角括弧は型の一部を為すが、変数には当てはまらない。　String[] args は良い。 String args[]　はダメ。


h4. 4.8.4 Switch statements 
スイッチ文

Terminology Note: Inside the braces of a switch block are one or more statement 

groups. Each statement group consists of one or more switch labels (either case FOO: 

or default:), followed by one or more statements.

用語についての注釈　　スイッチブロックの括弧のなかは一個以上の文グループです。

各文グループは一個以上のスイッチラベルと続く一個以上の文です。

h5. 4.8.4.1 Indentation

インデンテーション

As with any other block, the contents of a switch block are indented +2.

他のブロックがそうであるように、スイッチブロックのインデントは2です

After a switch label, a newline appears, and the indentation level is increased +2, 

exactly as if a block were being opened. The following switch label returns to the 

previous indentation level, as if a block had been closed.

スイッチラベルの後インデントレベルは2上がります。ちょうどブロックが開始したの

と同じようにです。

次のスイッチラベルはあたかもブロックの終わったように、前のインデンテーションレ

ベルに戻ります

h5. 4.8.4.2 Fall-through: commented 
フォールスルー　コメントを入れる


スイッチブロック内では、各ステートメントグループは突然止まる（break でかcontinue , return か例外スローか）か
実行が次のステートメントグループに進むようなコメントが付けられるかのみです。
フォールスルーということを示すどんなコメントも効果的です。// fall through　など。
この特別なコメントは、最後のステートメントグループには必要ありません。

例えば：

<pre>
switch (input) {
 case 1:
 case 2:
 prepareOneOrTwo();
 // fall through
 case 3:
 handleOneTwoOrThree();
 break;
 default:
 handleLargeNumber(input);
}
</pre>

h5. 4.8.4.3 default 節は必要

各スイッチ文はデフォルトステートメントグループがたとえコードがなかったとしても必要です。

h4. 4.8.5 アノテーション

クラス、メソッド、コンストラクタに付けられるアノテーションは、ドキュメンテーションブロックの直後にすぐ
配置されます。そして、各アノテーションは１行に１個設定されます。
これらの改行は行折り返し(4.5 節　行折り返し) に従いません。それ故、インデンテーションレベルも上がりません。
例えば：

<pre>
@Override
@Nullable
public String getNameIfPresent() { ... }
</pre>


例外：パラメータ無しのアノテーションが１個だけの場合はシグネチャー行の先頭に来ても良いです。
例えば：

<pre>
@Override public int hashCode() { ... }
</pre>

フィールドへのアノテーションもドキュメンテーションブロックの直後です。
しかしこの場合、複数のアノテーションが同じ行に現れても良いです。
例：

<pre>
@Partial @Mock DataLoader loader;
</pre>

パラメータや、ローカル変数へのアノテーションについては特にルールはありません。

h4. 4.8.6 コメント



h5. 4.8.6.1 Block comment style 
ブロックコメントスタイル

Block comments are indented at the same level as the surrounding code. They may be in /* ... */ style or // ... style. For multi-line /* ... */ comments, subsequent lines must start with * aligned with the * on the previous line.
ブロックコメントは周りのコードと同じレベルにインデントされる。/**/でも　　//でも良い。複数行/**/コメントについては*の位置を先頭行の米と同じに揃えなくてはならない。

<pre>
/*
 * This is          // And so           /* Or you can
 * okay.            // is this.          * even do this. */
 */
</pre>

Comments are not enclosed in boxes drawn with asterisks or other characters.
コメントはアスタリスクや他の文字で描かれた箱で囲われることは無い。


Tip: When writing multi-line comments, use the /* ... */ style if you want automatic code formatters to re-wrap the lines when necessary (paragraph-style). Most formatters don't re-wrap lines in // ... style comment blocks.
Tip: 複数行コメントを書く際必要に応じ自動フォーマット機能で行折り返ししたい場合は/**/スタイルを使うと良い。多くのフォーマッタは//　スタイルのコメントの改行を直さない。

4.8.7 Modifiers 
修飾子

Class and member modifiers, when present, appear in the order recommended by the Java Language Specification:
クラスやメンバの修飾子はJava言語仕様が推奨する順序で出現しなくてはならない。

<pre>
public protected private abstract static final transient volatile synchronized native strictfp
</pre>


4.8.8 Numeric Literals 
数値リテラル

long-valued integer literals use an uppercase L suffix, never lowercase (to avoid confusion with the digit 1). For example, 3000000000L rather than 3000000000l.
長い数値リテラルは大文字のLを末尾に使う。小文字は使わない。数値1との混乱を避ける。例えば　　3000000l ではなく300000Lを使う。

h2. 5 Naming 
命名

h3. 5.1 Rules common to all identifiers 
すべての識別子への共通ルール


識別子はASCII文字のみを使い、数字と大文字小文字とアンダースコアである。
それゆえ、有効な識別子名は正規表現　\w+にマッチする。


Googleスタイルでは、name_, mName, s_name や kName といったような特別な接尾辞・接頭辞は使われない。


h3. 5.2 識別子の種類ごとのルール

h4. 5.2.1 パッケージ名


パッケージ名はすべて小文字で連続する単語をそのまま繋げる。アンダースコアは使わない。
例えば、
com.example.deepspace,
であって、
com.example.deepSpace や com.example.deep_space
は使わない。


h4. 5.2.2 クラス名


クラス名は大文字キャメルケースで命名する。

クラス名は大抵名詞か名詞句です。例えば、Character や、ImmutableList です。
インターフェース名も名詞か名詞句です。例えば List です。
しかし、場合によっては形容詞や形容詞句になります。例えば、Readable です。

アノテーション型に対する特定のルールや確立した規約はありません。


テストクラスはテスト対象クラス名で始まり、Testで終わるよう命名されます。
例えばHashTest や、 HashIntegrationTest です。


h4. 5.2.3 メソッド名


メソッド名は、小文字キャメルケースで命名されます。


メソッド名は大抵動詞か動詞句です。例えば、sendMessage や stopです。

アンダースコアはJUnitのメソッド名で、論理的コンポーネント名を分離する場合で使ってよいです。
典型的なパターンは　test<MethodUnderTest>_<state>　で、例えば testPop_emptyStackです。
テストメソッドを命名する正しい唯一の方法はありません。


h4. 5.2.4 定数名

定数は コンスタントケースで命名します。すべて大文字で、各単語をアンダースコアで区切ります。
しかし定数とは何でしょう？いいですか？

すべての定数はstatic finalなフィールドです。しかし、すべてのstatic finalなフィールドが定数であるとは限りません。
コンスタントケースを選ぶ前に、そのフィールドが定数と感じるか考えてみましょう。例えば、
そのインスタンスの可視な状態が変更できるならば、殆どの場合定数ではありません。
決して変更されないオブジェクトの振りをするだけでは大抵不十分です。例えば、

<pre>
// 定数である
static final int NUMBER = 5;
static final ImmutableList<String> NAMES = ImmutableList.of("Ed", "Ann");
static final Joiner COMMA_JOINER = Joiner.on(',');  // Joiner は不変であるので。
static final SomeMutableType[] EMPTY_ARRAY = {};
enum SomeEnum { ENUM_CONSTANT }

// 定数でない
static String nonFinal = "non-final";
final String nonStatic = "non-static";
static final Set<String> mutableCollection = new HashSet<String>();
static final ImmutableSet<SomeMutableType> mutableElements = ImmutableSet.of(mutable);
static final Logger logger = Logger.getLogger(MyClass.getName());
static final String[] nonEmptyArray = {"these", "can", "change"};
</pre>

これらの名前は大抵名詞か名詞句です。




h4. 5.2.5 定数でないフィールド名

定数でないフィールド名（staticであってもなくても）は小文字キャメルケースで命名されます。

これらの名前は大抵名詞か名詞句です。例えば computedValues や index です。


h4. 5.2.6 パラメータ名


Parameter names are written in lowerCamelCase.
パラメータ名は小文字のキャメルケースです。
One-character parameter names should be avoided.
一文字のパラメータ名は避けるべきです。

5.2.7 Local variable names 
ローカル変数名

Local variable names are written in lowerCamelCase, and can be abbreviated more liberally than other types of names.
ローカル変数名は小文字キャメルケースで命名されます。
他の種類の命名よりも自由に短縮されます。
However, one-character names should be avoided, except for temporary and looping variables.
しかしながら一文字の名前は一時的なループ変数を除いて避けるべきです。
Even when final and immutable, local variables are not considered to be constants, and should not be styled as constants.
finalで不変であってもローカル変数は定数とは見なされないのでそのようにスタイルされるのは避けるべきです。

h4. 5.2.8 Type variable names 
型変数名

型変数名は以下の２つのやり方のうちいずれかで命名されます。

* 一つの大文字アルファベット。それに１個の数字が続いて良い。例：E, T, X, T2
* クラスの命名（5.2.2節 クラス名 参照）の後ろに、大文字Tを付加する。例： RequestT, FooBarT

h3. 5.3 キャメルケースの定義

"IPv6"や、"iOS"のような頭字語や見慣れない単語があるように、英語のフレーズをキャメルケースに変換する
合理的な方法はいくつかあります。
正確さを維持するため、Google Styleでは以下のように（ほぼ）決定的な方法を定義します。

名前の通常の形から始めて、

# 言葉を素のASCIIに変換し、アポストロフィを除去する。例えば、"Müller's  algorithm" は "Muellers algorithm"に変換される。
# これを単語に分割する。つまり、スペースや残っている句読点、ハイフンで分離する。
** 推奨：もしもある単語が一般的にキャメルケースの形になっていたら、これを分解する。
（例：「AdWords」 を 「ad words」にする。）「iOS」のような単語は本当はキャメルケースになっていない
規約に当てはまらないのでこの推奨は適用しないことに注意する。
# （頭字語を含めて）すべてを小文字にする。そして最初の文字を大文字にする。
** 各単語とは大文字キャメルケースとなるか、最初の単語を除いて小文字キャメルケースになる。
# 最後に、すべての単語を１個の識別子として連結する。

元々の大文字小文字はほぼ無視される。例えば、


|元々の形|正しい変換例|誤った変換例|
|"XML HTTP request"|XmlHttpRequest|XMLHTTPRequest|
|"new customer ID"|newCustomerId|newCustomerID|
|"inner stopwatch"|innerStopwatch|innerStopWatch|
|"supports IPv6 on iOS?"|supportsIpv6OnIos|supportsIPv6OnIOS|
|"YouTube importer"|YouTubeImporter YoutubeImporter [1]||


fn1. やってよいが推奨されない。


.h2 6 Programming Practices プログラミングの実践

.h3 6.1 @Override を常に使う。


A method is marked with the @Override annotation whenever it is legal. This includes a class method overriding a superclass method,
 a class method implementing an interface method, and an interface method respecifying a superinterface method.
許される場所ならばメソッドはOverrideアノテーションをつけられます。これは親クラスのメソッドをオーバーライドするクラスメソッドや、
インターフェースのメソッドを実装するクラスのメソッドや、親インターフェースのメソッドを再定義する子インターフェースのメソッドにも
当てはまります。



.h3 6.2 Caught exceptions: not ignored 
キャッチした例外を無視しない。

Except as noted below, it is very rarely correct to do nothing in response to a caught exception.
 (Typical responses are to log it, or if it is considered "impossible", rethrow it as an AssertionError.)

以下の例外を除き、キャッチした例外に対してなにも対応しないのが正しいことはめったにありません。
大抵の対応はログを取るか、ありえない場合ならばAssertionErrorとして再スローすることです。


When it truly is appropriate to take no action whatsoever in a catch block, the reason this is justified is explained in a comment.

キャッチ節でなにもしないことが本当に適切であるならば、それを正当化する理由をコメントで説明します。

<pre>
try {
  int i = Integer.parseInt(response);
  return handleNumericResponse(i);
} catch (NumberFormatException ok) {
  // 数字ではない。このような場合もあるので別の処理を続ける。
}
return handleTextResponse(response);
</pre>


Exception: in tests, a caught exception may be ignored without comment if it is named expected. 
The following is a very common idiom for ensuring that the method under test does throw an exception of the expected type,
 so a comment is unnecessary here.

例外：テストにおいて例外がスローされることを期待する場合はキャッチした例外はコメントなしで無視されます。
以下の例はテスト対象のメソッドが期待した型の例外をスローすることを確認するためのよくあるイディオムで、
コメントは不要です。

<pre>
try {
  emptyStack.pop();
  fail();
} catch (NoSuchElementException expected) {
}
</pre>



.h3 6.3 Static members: qualified using class 

staticなメンバーはクラスを使って修飾する。

When a reference to a static class member must be qualified, it is qualified with that class's name,
 not with a reference or expression of that class's type.

staticなメンバーへの参照の場合はクラス名で修飾されます。そのクラスの型の変数や式で修飾してはいけません。
(TODO 訳語見直し)

<pre>
Foo aFoo = ...;
Foo.aStaticMethod(); // 良い
aFoo.aStaticMethod(); // 悪い
somethingThatYieldsAFoo().aStaticMethod(); // とても悪い
</pre>


6.4 Finalizers: not used 
ファイナライザは使わない。

It is extremely rare to override Object.finalize.
Objectクラスのfinalize()メソッドを使うケースは非常に稀です。

Tip: Don't do it. If you absolutely must, first read and understand Effective Java Item 7, "Avoid Finalizers," very carefully, and then don't do it.

TIP: これをやってはいけません。先に Effective JavaのItem7「ファイナライザを避ける」を必ず熟読しなくてはなりません。そしてこれをやってはいけません。




.h2 7 Javadoc 

.h3 7.1 フォーマット

.h4 7.1.1 一般的なフォーマット


The basic formatting of Javadoc blocks is as seen in this example:

Javadocブロックの基本的なフォーマットはこの例で表されます。

<pre>
/**
 * Multiple lines of Javadoc text are written here,
 * wrapped normally...
 */
public int method(String p1) { ... }
</pre>

... or in this single-line example:
一行の例はこれです。

<pre>
/** An especially short bit of Javadoc. */
</pre>

The basic form is always acceptable. The single-line form may be substituted when there are no at-clauses present,
 and the entirety of the Javadoc block (including comment markers) can fit on a single line.

基本的な形は常に適用されます。 @節がない場合や、コメントマーカを含めたJavadocブロック全体において１行で書くほうが体裁が良い場合は
一行の形で代用できます。


.h4 7.1.2 Paragraphs 段落


One blank line—that is, a line containing only the aligned leading asterisk (*)—appears between paragraphs, 
and before the group of "at-clauses" if present. Each paragraph but the first has <p> immediately before the first word, with no space after.

１個の空行、つまり、行頭に並べられたアスタリスク(*)のみの行が段落間と@節グループの前に挿入される。
先頭が<p>でないそれぞれの段落は

先頭以外のすべての段落は、最初の単語の前に<p>が入れられる。
(TODO with no space after.の意味は？)


.h4 7.1.3 @節　（javadoc タグ）At-clauses 

（訳注：@param と言った節のこと。参照 http://docs.oracle.com/javase/jp/7/technotes/tools/windows/javadoc.html#javadoctags）
GoogleJavaStyleでしか使っていない用語なので、全部javadoc タグに変えたほうがよいか。）

Any of the standard "at-clauses" that are used appear in the order @param, @return, @throws, @deprecated, 
and these four types never appear with an empty description. When an at-clause doesn't fit on a single line, 
continuation lines are indented four (or more) spaces from the position of the @.

標準の＠節で、使われるものは @param, @return, @throws, @deprecatedの順で現れる。これらの４つは空の記述には現れない。
＠節が１行コメントに収まらない場合、２行目以降は@の位置からスペース４個以上インデントされる。


.h3 7.2 The summary fragment 要約の記述

The Javadoc for each class and member begins with a brief summary fragment. 
This fragment is very important: it is the only part of the text that appears in certain contexts such as class and method indexes.

クラスとメンバーのJavadocは簡単な要約の記述から始まります。
この記述はとても重要です。クラスやメソッドの索引のような特別な場所に現れる唯一のテキストだからです。


This is a fragment—a noun phrase or verb phrase, not a complete sentence. 
It does not begin with A {@code Foo} is a..., or This method returns..., nor does it form a complete imperative sentence like Save the record.. 
However, the fragment is capitalized and punctuated as if it were a complete sentence.

この記述は名詞句か動詞句であって文であってはなりません。
「このクラス {@code Foo} は、、、」とか「このメソッドはナニナニを返す。」で始まってはいけませんし、「結果を保存する。」といった
命令文でもいけません。しかしながらこの記述はあたかも文であるかのように大文字化され、句読点が付けられます。
（TODO 訳見直し）

Tip: A common mistake is to write simple Javadoc in the form /** @return the customer ID */. 
This is incorrect, and should be changed to /** Returns the customer ID. */.

TIP: /** @return the customer ID */といった簡単なJavadocを書くことはよくある間違いです。
これは不正で、正しくは以下のように直されるべきです。/** Returns the customer ID. */.




.h3 7.3 Where Javadoc is used Javadocが使われる場所



At the minimum, Javadoc is present for every public class, and every public or protected member of such a class, with a few exceptions noted below.

少なくとも、javadocはpublicなクラスとそのクラスのpublic protected なメンバーに書かれます。但し以下の例外が有ります。

.h4 7.3.1 Exception: self-explanatory methods 例外　自己叙述的なメソッド。


Javadoc is optional for "simple, obvious" methods like getFoo, in cases where there really and truly is nothing else worthwhile to say but "Returns the foo".

javadocはgetFooのような簡単で明確なメソッドの場合は必須ではありません。つまり、「fooを返す」以外の意味ある情報が本当に無い場合です。


The test methods of a unit test class are perhaps the most common example of this exemption. These methods can usually be named descriptively enough that no additional documentation is needed.


ユニットテストクラスのテストメソッドはおそらくこの例外の最も一般的な例外です。このようなメソッドは他の追加の文書が不要なほど内容がわかるように命名されます。


Tip: Important: it is not appropriate to cite this exception to justify omitting relevant information that a typical reader might need to know. For example, for a method named getCanonicalName, don't omit its documentation (with the rationale that it would say only /** Returns the canonical name. */) if a typical reader may have no idea what the term "canonical name" means!

Tip: 重要：この例外を典型的な読者が知りたがるような関連情報を省略することを正当化するために引用するのは
適切ではありません。例えば、「getCanonicalName」というメソッドにおいて典型的な読者が「canonical name」という語の意味を
知らないかもしれない場合、（単に/** Returns the canonical name. */と書くだけであるという理由で）省略してはいけません。




.h4 7.3.2 Exception: overrides 例外　オーバーライドするメソッド

親クラスのメソッドをオーバーライドするメソッドについてはJavadocは必須ではありません。


Javadoc is not always present on a method that overrides a supertype method.

.h4 7.3.3 追加のjavadoc



Classes and members that are not visible outside their package still have Javadoc as needed. Whenever an implementation comment would be used to define the overall purpose or behavior of a class, method or field, that comment is written as Javadoc instead. (It's more uniform, and more tool-friendly.)

パッケージ外から可視でないクラスやメンバーでもJavadocは必要です。
クラス・メソッド・フィールドの挙動や全体的な目的を定める時実装コメントが必要な場合は、
そのコメントはJavadocで書かれます。（より統一的で、ツールとの親和性も高いです。）



